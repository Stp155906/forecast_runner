# -*- coding: utf-8 -*-
"""Copy of Full_Year_day_forecast_mundane_events.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p4nKQsi3omduvYP8flIB8Aiyg8CVfXSc

# FIRST BLOCK
"""

# @title
# Colab Cell — Dual Export: 7-Day + Annual (ephemeris-only) with Eclipse tagging
# Files per folder: forecast_mundaneevents.json, forecast_aspects_all.json,
#                   forecast_aspects_matched.json, forecast_aspects_unmatched.json,
#                   forecast_moon_events.json, forecast_eclipses.json

from __future__ import annotations
import json, re, requests, math, os
from datetime import datetime, timedelta, timezone, date
from typing import Dict, List, Any, Optional


# ----------------
# Path config (works on mac + GitHub)
# ----------------
import os
from pathlib import Path

def _script_dir() -> Path:
    # __file__ exists for normal Python runs (mac, GitHub). In rare cases use CWD.
    return Path(__file__).resolve().parent if "__file__" in globals() else Path.cwd()

# Allow override with env var, otherwise put everything inside the repo folder.
BASE_DIR = Path(os.environ.get("FORECAST_BASE_DIR", str(_script_dir())))

DIR_7D     = BASE_DIR / "forecast_7d"
DIR_ANNUAL = BASE_DIR / "forecast_annual"
DIR_SAMPLE = BASE_DIR / "sample_data"   # used by the test block, harmless if unused

def ensure_dir(p: str | Path):
    Path(p).mkdir(parents=True, exist_ok=True)


# ---------------------------
# Live feed URLs (your repos)
# ---------------------------
RULES_URL   = "https://raw.githubusercontent.com/Stp155906/mundane-cycles/refs/heads/main/rules.json"
ECHOES_URL  = "https://raw.githubusercontent.com/Stp155906/mundane-cycles/refs/heads/main/echo_catalog.json"
ASPECTS_URL = "https://raw.githubusercontent.com/Stp155906/weekly-aspects/refs/heads/main/weekly_aspects.json"
EPHEMERIS_URL_TMPL = "https://raw.githubusercontent.com/Stp155906/ephemeris/refs/heads/main/{year}_ephemeris_with_signs.json"

SYNODIC_DAYS = 29.53059
HALF_SYNODIC = SYNODIC_DAYS / 2.0
EPHEMERIS_LOOKAHEAD_DAYS = 60  # search window for next lunations

# Eclipse heuristics (only applied if Node is present in your ephemeris)
ECLIPSE_NODE_THRESHOLD_NEW_DEG  = 17.0  # ~solar eclipse window
ECLIPSE_NODE_THRESHOLD_FULL_DEG = 11.0  # ~lunar eclipse window
NODE_KEYS = ["true node", "mean node", "north node", "node", "lunar node", "rahu"]

# ----------------
# JSON helpers
# ----------------
def _strip_json_comments(s: str) -> str:
    s = re.sub(r'(?m)^[ \t]*//.*$', '', s)
    s = re.sub(r'/\*[\s\S]*?\*/', '', s)
    s = re.sub(r',\s*([}\]])', r'\1', s)
    return s

def load_json5(url: str) -> Any:
    r = requests.get(url, timeout=30)
    r.raise_for_status()
    txt = r.text
    try:
        return json.loads(txt)
    except json.JSONDecodeError:
        return json.loads(_strip_json_comments(txt))

# ----------------
# Canonical + UI utils
# ----------------
_ASPECT_CANON = {
    "□": "square", "square":"square",
    "△": "trine", "trine":"trine",
    "☍": "opposition", "opposition":"opposition",
    "☌": "conjunction", "conjunction":"conjunction",
    "✶": "sextile", "sextile":"sextile",
    "semi-sextile":"semi-sextile", "semisextile":"semi-sextile"
}
_ASPECT_SYMBOL = {"square":"□","trine":"△","opposition":"☍","conjunction":"☌","sextile":"✶","semi-sextile":"⚺"}

def canonical_aspect(s: str) -> str:
    return _ASPECT_CANON.get((s or "").strip().lower(), (s or "").strip().lower())

def symbol_for(aspect_name: str) -> str:
    return _ASPECT_SYMBOL.get(canonical_aspect(aspect_name), aspect_name)

def tcase(x: str) -> str:
    return (x or "").strip().title()

def pretty_date_str(yyyy_mm_dd: str) -> str:
    try:
        dt = datetime.strptime(yyyy_mm_dd, "%Y-%m-%d").date()
        try:    return dt.strftime("%b %-d, %Y")
        except: return dt.strftime("%b %#d, %Y")
    except:
        return yyyy_mm_dd

def render_template(s: str, d: str) -> str:
    dl = pretty_date_str(d)
    return (s or "").replace("{{date_local}}", dl).replace("{date_local}", dl)

def build_subtitle_from_aspect(a: Dict[str,Any]) -> str:
    b1 = tcase(a.get("body1","")); b2 = tcase(a.get("body2",""))
    pos = a.get("positions") or {}
    s1 = (pos.get(a.get("body1",""),{}) or {}).get("sign","")
    s2 = (pos.get(a.get("body2",""),{}) or {}).get("sign","")
    sym = symbol_for(a.get("aspect_name",""))
    orb = float(a.get("orb_deg", 0.0)); ph = (a.get("phase") or "")
    left  = f"{b1}" + (f" in {s1}" if s1 else "")
    right = f"{b2}" + (f" in {s2}" if s2 else "")
    tail  = f" — orb {orb:.1f}°" + (f" ({ph})" if ph else "")
    return f"{left} {sym} {right}{tail}"

# ----------------
# Data fetchers
# ----------------
def fetch_rules_and_echoes():
    rules_doc = load_json5(RULES_URL) or {}
    echoes_doc = load_json5(ECHOES_URL) or {}
    rules  = rules_doc.get("rules", []) if isinstance(rules_doc, dict) else []
    echoes = echoes_doc.get("echoes", []) if isinstance(echoes_doc, dict) else []
    print(f"TE ▶︎ loaded rules={len(rules)} echoes={len(echoes)}")
    return rules, echoes

def fetch_weekly_aspects_preserve() -> List[Dict[str,Any]]:
    data = load_json5(ASPECTS_URL)
    weekly: List[Dict[str,Any]] = []
    if isinstance(data, dict) and "weekly_aspects" in data and isinstance(data["weekly_aspects"], list):
        for item in data["weekly_aspects"]:
            if isinstance(item, dict) and "date" in item and isinstance(item.get("aspects"), list):
                weekly.append({"date": item["date"], "aspects": item["aspects"]})
    elif isinstance(data, dict):
        for d, lst in sorted(data.items()):
            if isinstance(lst, list):
                weekly.append({"date": d, "aspects": lst})
    elif isinstance(data, list):
        by_day: Dict[str, List[Dict[str,Any]]] = {}
        for a in data:
            if isinstance(a, dict) and "date" in a:
                by_day.setdefault(a["date"], []).append(a)
        for d in sorted(by_day.keys()):
            weekly.append({"date": d, "aspects": by_day[d]})
    print(f"TE ▶︎ weekly_aspects days={len(weekly)}")
    return weekly

# ---- Ephemeris cache + loaders (supports YYYY-MM-DD, YYYY-MM, or Month names)
LOADED_EPH_YEARS = set()
_DATE_RE  = re.compile(r"^\d{4}-\d{2}-\d{2}$")
_MONTH_RE = re.compile(r"^\d{4}-\d{2}$")

def _month_name_to_num(mname: str) -> Optional[int]:
    try:
        return datetime.strptime(mname.strip(), "%B").month
    except:
        return None

def fetch_ephemeris_for_year(year: int) -> Dict[str, Dict[str,str]]:
    """
    Supports:
      A) {"YYYY-MM-DD": {...}}
      B) {"YYYY-MM": {"1": {...}, ...}}
      C) {"January": {"1": {...}, ...}, ...}
    -> Flattens to {"YYYY-MM-DD": {"sun":"...", "moon":"...", ...}, ...}
    """
    if year in LOADED_EPH_YEARS:
        return {}
    url = EPHEMERIS_URL_TMPL.format(year=year)
    data = load_json5(url) or {}
    norm: Dict[str, Dict[str,str]] = {}

    if isinstance(data, dict):
        for key, val in data.items():
            # Pattern A
            if isinstance(val, dict) and _DATE_RE.match(key):
                norm[key] = {k.lower(): v for k, v in val.items()}
                continue
            # Pattern B
            if isinstance(val, dict) and _MONTH_RE.match(key):
                month_prefix = key  # YYYY-MM
                for day_key, bodies in val.items():
                    if not isinstance(bodies, dict): continue
                    try:
                        dd = int(str(day_key).strip())
                        iso = f"{month_prefix}-{dd:02d}"
                        norm[iso] = {k.lower(): v for k, v in bodies.items()}
                    except: pass
                continue
            # Pattern C (Month name)
            mnum = _month_name_to_num(key)
            if isinstance(val, dict) and mnum is not None:
                for day_key, bodies in val.items():
                    if not isinstance(bodies, dict): continue
                    try:
                        dd = int(str(day_key).strip())
                        iso = f"{year}-{mnum:02d}-{dd:02d}"
                        norm[iso] = {k.lower(): v for k, v in bodies.items()}
                    except: pass

    LOADED_EPH_YEARS.add(year)
    print(f"TE ▶︎ ephemeris days={len(norm)} (year={year})")
    return norm

def extract_sign_from_ephemeris(pos: str) -> str:
    return (pos or "").split(" ")[0].title().strip()

# ----------------
# Rule matching (for aspect cards)
# ----------------
def rule_matches_aspect(rule: Dict[str,Any], a: Dict[str,Any]) -> bool:
    if rule.get("type") != "aspect_theme":
        return False
    m = rule.get("match", {})
    rb = [tcase(x) for x in (m.get("bodies_exact") or [])]
    if rb:
        pair = sorted([tcase(a.get("body1","")), tcase(a.get("body2",""))])
        if pair != sorted(rb): return False
    if canonical_aspect(m.get("aspect_name_exact","")) != canonical_aspect(a.get("aspect_name","")):
        return False
    if float(a.get("orb_deg", 999.0)) > float(m.get("orb_max_deg", 999.0)):
        return False
    if float(a.get("importance_score", 0.0)) < float(m.get("importance_min", 0.0)):
        return False
    if m.get("require_signs"):
        need1 = tcase(m.get("body1_sign","")); need2 = tcase(m.get("body2_sign",""))
        pos = a.get("positions") or {}
        p1 = tcase((pos.get(a.get("body1",""),{}) or {}).get("sign",""))
        p2 = tcase((pos.get(a.get("body2",""),{}) or {}).get("sign",""))
        if not ((p1==need1 and p2==need2) or (p1==need2 and p2==need1)): return False
    return True

# ----------------
# Ephemeris & Moon math
# ----------------
SIGNS = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"]
SIGN_TO_INDEX = {s:i for i,s in enumerate(SIGNS)}
OPPOSITE_SIGN = {SIGNS[i]: SIGNS[(i+6)%12] for i in range(12)}

def _parse_lon_deg(pos: str) -> Optional[float]:
    if not pos: return None
    clean = pos.replace("’"," ").replace("'", " ")
    m = re.search(r"([A-Za-z]+)\s+(\d+)\s+(\d+)", clean)
    if not m: return None
    sign, deg, minute = m.group(1).title(), int(m.group(2)), int(m.group(3))
    idx = SIGN_TO_INDEX.get(sign)
    if idx is None: return None
    return idx*30 + deg + minute/60.0

def _body_lon(eph_by_day: Dict[str,Dict[str,str]], day: str, body: str) -> Optional[float]:
    row = eph_by_day.get(day) or {}
    pos = row.get(body.lower())
    return _parse_lon_deg(pos)

def _angle_diff(a: float, b: float) -> float:
    d = (b - a) % 360.0
    if d >= 180.0: d -= 360.0
    return d

def _node_lon(eph_by_day: Dict[str,Dict[str,str]], date_iso: str) -> Optional[float]:
    row = eph_by_day.get(date_iso) or {}
    for k in NODE_KEYS:
        if k in row:
            return _parse_lon_deg(row[k])
    return None

def _maybe_tag_eclipse(eph_by_day: Dict[str,Dict[str,str]], ev: Dict[str,Any]) -> Dict[str,Any]:
    node = _node_lon(eph_by_day, ev["date"])
    sun  = _body_lon(eph_by_day, ev["date"], "sun")
    if node is None or sun is None:
        return ev
    sep = abs(_angle_diff(sun, node))
    out = dict(ev)
    if ev["phase"] == "new"  and sep <= ECLIPSE_NODE_THRESHOLD_NEW_DEG:  out["kind"] = "solar_eclipse"
    if ev["phase"] == "full" and sep <= ECLIPSE_NODE_THRESHOLD_FULL_DEG: out["kind"] = "lunar_eclipse"
    return out

def _phase_name_from_angle(delta_deg: float) -> str:
    a = delta_deg % 360.0
    if   a < 22.5 or a >= 337.5: return "new"
    elif a < 67.5:  return "waxing crescent"
    elif a < 112.5: return "first quarter"
    elif a < 157.5: return "waxing gibbous"
    elif a < 202.5: return "full"
    elif a < 247.5: return "waning gibbous"
    elif a < 292.5: return "last quarter"
    else:           return "waning crescent"

def _closest_phase_on_or_after(start_iso: str, eph_by_day: Dict[str,Dict[str,str]], target: str, horizon=EPHEMERIS_LOOKAHEAD_DAYS) -> Optional[Dict[str,Any]]:
    """Pick the day within horizon where Moon-Sun angle best matches 0° (new) or 180° (full)."""
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    want = 0.0 if target == "new" else 180.0
    best = None
    for i in range(0, horizon+1):
        d = (start + timedelta(days=i)).isoformat()
        sun = _body_lon(eph_by_day, d, "sun")
        moon = _body_lon(eph_by_day, d, "moon")
        if sun is None or moon is None: continue
        delta = ((moon - sun) % 360.0)
        dist = abs(((delta - want + 180.0) % 360.0) - 180.0)
        if (best is None) or (dist < best[0]) or (dist == best[0] and i < best[1]):
            best = (dist, i, d)
    if not best: return None
    return {"date": best[2], "phase": target, "kind": target, "estimated": True}

# ---- Find ALL lunations inside a window ----
def list_lunations_for_window(eph_by_day: Dict[str,Dict[str,str]], start_iso: str, end_iso: str) -> List[Dict[str,Any]]:
    events: List[Dict[str,Any]] = []
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    end   = datetime.strptime(end_iso,   "%Y-%m-%d").date()

    # helper to iterate a sequence (new or full)
    def collect_sequence(which: str):
        cur = start
        while cur <= end + timedelta(days=1):
            nxt = _closest_phase_on_or_after(cur.isoformat(), eph_by_day, which, horizon=40)
            if not nxt: break
            d = datetime.strptime(nxt["date"], "%Y-%m-%d").date()
            if d > end: break
            events.append(_maybe_tag_eclipse(eph_by_day, nxt))
            cur = d + timedelta(days=2)  # hop to next cycle

    collect_sequence("new")
    collect_sequence("full")
    # sort + de-dup just in case
    events.sort(key=lambda e: (e["date"], 0 if e["phase"]=="new" else 1))
    uniq = []
    seen = set()
    for e in events:
        k = (e["date"], e["phase"])
        if k not in seen:
            seen.add(k); uniq.append(e)
    return uniq

# ----------------
# Lunation pair computation for countdowns (robust)
# ----------------
def compute_two_phases(start_iso: str, eph_by_day: Dict[str,Dict[str,str]]) -> Dict[str,Dict[str,Any]]:
    nxt_new  = _closest_phase_on_or_after(start_iso, eph_by_day, "new",  EPHEMERIS_LOOKAHEAD_DAYS)
    nxt_full = _closest_phase_on_or_after(start_iso, eph_by_day, "full", EPHEMERIS_LOOKAHEAD_DAYS)
    d_start = datetime.strptime(start_iso, "%Y-%m-%d").date()

    if not nxt_new and not nxt_full:
        nxt_new  = {"date": (d_start + timedelta(days=1)).isoformat(), "phase":"new",  "kind":"new",  "estimated": True}
        nxt_full = {"date": (d_start + timedelta(days=HALF_SYNODIC)).isoformat(), "phase":"full", "kind":"full", "estimated": True}
    elif not nxt_new and nxt_full:
        dF = datetime.strptime(nxt_full["date"], "%Y-%m-%d").date()
        nxt_new = {"date": (dF - timedelta(days=HALF_SYNODIC)).isoformat(), "phase":"new", "kind":"new", "estimated": True}
    elif not nxt_full and nxt_new:
        dN = datetime.strptime(nxt_new["date"], "%Y-%m-%d").date()
        nxt_full = {"date": (dN + timedelta(days=HALF_SYNODIC)).isoformat(), "phase":"full", "kind":"full", "estimated": True}

    if nxt_new["date"] == nxt_full["date"]:
        dN = datetime.strptime(nxt_new["date"], "%Y-%m-%d").date()
        nxt_full = {"date": (dN + timedelta(days=HALF_SYNODIC)).isoformat(), "phase":"full", "kind":"full", "estimated": True}

    nxt_new  = _maybe_tag_eclipse(eph_by_day, nxt_new)
    nxt_full = _maybe_tag_eclipse(eph_by_day, nxt_full)
    return {"next_new": nxt_new, "next_full": nxt_full}

def phase_nice_label(phase: str, kind: str|None) -> str:
    k = (kind or phase or "").lower()
    if k == "solar_eclipse": return "Solar Eclipse"
    if k == "lunar_eclipse": return "Lunar Eclipse"
    return "New Moon" if (phase or "").lower()=="new" else "Full Moon"

# ----------------
# Moon rule copy helpers (pull sign-specific titles, themes, echoes)
# ----------------
def find_moon_rule(rules: List[Dict[str,Any]], phase_for_rules: str, sign: str) -> Optional[Dict[str,Any]]:
    phase_for_rules = (phase_for_rules or "").lower()
    sign  = tcase(sign)
    best = None
    for r in rules:
        if r.get("type") != "moon_phase": continue
        m = r.get("match", {})
        if (m.get("phase","").lower() != phase_for_rules): continue
        need_sign = tcase(m.get("sign",""))
        if need_sign and sign == need_sign:
            if (best is None) or (float(r.get("priority",0)) > float(best.get("priority",0))):
                best = r
    if best: return best
    for r in sorted([x for x in rules if x.get("type")=="moon_phase"], key=lambda z: float(z.get("priority",0)), reverse=True):
        m = r.get("match", {})
        if (m.get("phase","").lower() == phase_for_rules) and not m.get("sign"):
            return r
    return None

def build_moon_copy_from_rules(rules, echoes, phase_for_rules, sign, date_iso, default_label) -> Dict[str,Any]:
    r = find_moon_rule(rules, phase_for_rules, sign)
    if r:
        title_tmpl = (r.get("copy", {}) or {}).get("title_template") or (
            f"{tcase(sign)} {default_label} → {{date_local}}" if sign else f"{default_label} → {{date_local}}"
        )
        title = render_template(title_tmpl, date_iso)
        future_theme = (r.get("copy", {}) or {}).get("future_theme", "")
        echo_ids = r.get("echo_ids") or []
        echo_map = {e.get("id"): e for e in echoes}
        echo_objs = [echo_map[eid] for eid in echo_ids if eid in echo_map]
        return {"title": title, "future_theme": future_theme or "Major tide change. Honor the phase’s tone.", "echoes": echo_objs, "rule_id": r.get("id","")}
    base = f"{tcase(sign)} {default_label}" if sign else default_label
    return {"title": f"{base} → {pretty_date_str(date_iso)}", "future_theme": "This upcoming lunation is a reset/culmination point. Notice what’s ending and what wants to begin.", "echoes": [], "rule_id": f"meta.{phase_for_rules}.default"}

# ----------------
# Build helpers
# ----------------
def daterange(start: date, days: int) -> List[str]:
    return [(start + timedelta(days=i)).isoformat() for i in range(days)]

def ensure_ephemeris_loaded(eph_by_day: Dict[str,Dict[str,str]], start: date, days: int):
    # Load from start.year up to at most next year (avoid 404 for far-future years).
    max_year = start.year + 1
    end_for_eph = start + timedelta(days=days + EPHEMERIS_LOOKAHEAD_DAYS)
    end_year = min(end_for_eph.year, max_year)
    for y in range(start.year, end_year + 1):
        eph_by_day.update(fetch_ephemeris_for_year(y))

def event_sign(eph_by_day, date_iso: str, phase: str, kind: Optional[str]) -> str:
    use_sun = (phase=="new") or (kind=="solar_eclipse")
    pos = (eph_by_day.get(date_iso, {}) or {}).get("sun" if use_sun else "moon")
    return extract_sign_from_ephemeris(pos) if pos else ""

def phase_label_for_day(eph_by_day, d: str) -> str:
    sun = _body_lon(eph_by_day, d, "sun")
    moon = _body_lon(eph_by_day, d, "moon")
    if sun is None or moon is None: return ""
    return _phase_name_from_angle((moon - sun) % 360.0)

# ----------------
# Main builder (generic window)
# ----------------
def build_window(start_date_str: str|None, days: int) -> Dict[str,Any]:
    today = datetime.now(timezone.utc).date()
    start = datetime.strptime(start_date_str, "%Y-%m-%d").date() if start_date_str else today
    window = daterange(start, days)

    rules, echoes = fetch_rules_and_echoes()
    weekly = fetch_weekly_aspects_preserve()

    # Load ephemeris for all years touched by (window + lookahead)
    eph_by_day: Dict[str, Dict[str,str]] = {}
    ensure_ephemeris_loaded(eph_by_day, start, days)

    # Index aspects by day
    by_day: Dict[str, List[Dict[str,Any]]] = {d: [] for d in window}
    for item in weekly:
        d = item.get("date")
        if d in by_day and isinstance(item.get("aspects"), list):
            by_day[d] = [dict(a) for a in item["aspects"]]

    # ----- META: next New & Full from window start -----
    pair = compute_two_phases(window[0], eph_by_day)
    next_new  = pair["next_new"]
    next_full = pair["next_full"]

    def _meta_block(nxt: Dict[str,Any]) -> Dict[str,Any]:
        d0 = datetime.strptime(window[0], "%Y-%m-%d").date()
        dN = datetime.strptime(nxt["date"], "%Y-%m-%d").date()
        label = phase_nice_label(nxt.get("phase",""), nxt.get("kind"))
        phase_for_rules = "new" if (nxt.get("phase")=="new" or nxt.get("kind")=="solar_eclipse") else "full"
        ev_sign = event_sign(eph_by_day, nxt["date"], nxt["phase"], nxt.get("kind"))
        copy_pack = build_moon_copy_from_rules(rules, echoes, phase_for_rules, ev_sign, nxt["date"], label)
        return {
            "phase": nxt.get("phase"),
            "kind": nxt.get("kind", nxt.get("phase")),
            "date": nxt["date"],
            "days_out": (dN - d0).days,
            "sign": ev_sign,
            "title": copy_pack["title"],
            "future_theme": copy_pack["future_theme"],
            "echoes": copy_pack["echoes"],
            "rule_id": copy_pack["rule_id"],
            "estimated": bool(nxt.get("estimated", False))
        }

    meta: Dict[str,Any] = {}
    meta["next_new_moon"]  = _meta_block(next_new)
    meta["next_full_moon"] = _meta_block(next_full)
    earlier = meta["next_new_moon"] if meta["next_new_moon"]["days_out"] <= meta["next_full_moon"]["days_out"] else meta["next_full_moon"]
    meta["next_lunation"] = {k: earlier[k] for k in earlier}

    result: Dict[str,Any] = {
        "generated_utc": datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00","Z"),
        "window": {"start": window[0], "days": days},
        "weekly_aspects": [],
        "meta": meta
    }

    # Build per-day cards
    for d in window:
        # Aspects + cards
        aspects = by_day.get(d, [])
        aspects_with_cards: List[Dict[str,Any]] = []
        for a in aspects:
            matches = [r for r in rules if r.get("type")=="aspect_theme" and rule_matches_aspect(r, a)]
            matches.sort(key=lambda r: float(r.get("priority", 0)), reverse=True)
            if matches:
                r0 = matches[0]
                title = r0.get("copy",{}).get("title") or render_template(r0.get("copy",{}).get("title_template",""), d)
                card = {
                    "state": "matched",
                    "rule_id": r0.get("id",""),
                    "title": title,
                    "subtitle": build_subtitle_from_aspect(a),
                    "future_theme": r0.get("copy",{}).get("future_theme",""),
                    "echoes": [e for e in echoes if e.get("id") in (r0.get("echo_ids") or [])]
                }
            else:
                sym = symbol_for(a.get("aspect_name",""))
                suffix = " — Harmony Flow" if canonical_aspect(a.get("aspect_name",""))=="trine" else ""
                title = f"{tcase(a.get('body1',''))} {sym} {tcase(a.get('body2',''))}{suffix}"
                card = {
                    "state": "unmatched",
                    "rule_id": "dev.aspect.unmatched",
                    "title": title,
                    "subtitle": build_subtitle_from_aspect(a),
                    "future_theme": "📜 No echoes linked for this aspect. Focus on the current geometry and vibe.",
                    "echoes": []
                }
            b = dict(a); b["card"] = card
            aspects_with_cards.append(b)

        # Moon anchor from ephemeris
        sun_lon = _body_lon(eph_by_day, d, "sun")
        moon_lon = _body_lon(eph_by_day, d, "moon")
        moon_phase = _phase_name_from_angle((moon_lon - sun_lon) % 360.0) if (sun_lon is not None and moon_lon is not None) else ""
        moon_sign = extract_sign_from_ephemeris((eph_by_day.get(d, {}) or {}).get("moon") or "")
        moon_blob = {"phase": moon_phase, "sign": moon_sign}

        moon_anchor_card = {
            "state": "moon_anchor",
            "rule_id": "meta.moon.anchor",
            "title": f"{(moon_phase or 'Moon').title()} (Anchor)",
            "subtitle": None,
            "future_theme": "Collective mood anchor. 📜 No echoes linked today. Focus on the present lunation tone.",
            "echoes": []
        }

        # Per-day countdowns
        pair_day = compute_two_phases(d, eph_by_day)
        # titles/theme pulled inside make_countdown-style copy via _meta_block-equivalent logic
        def _countdown(day_iso, nxt):
            d0 = datetime.strptime(day_iso, "%Y-%m-%d").date()
            dN = datetime.strptime(nxt["date"], "%Y-%m-%d").date()
            days_out = (dN - d0).days
            label = phase_nice_label(nxt.get("phase",""), nxt.get("kind"))
            phase_for_rules = "new" if (nxt.get("phase")=="new" or nxt.get("kind")=="solar_eclipse") else "full"
            ev_sign = event_sign(eph_by_day, nxt["date"], nxt["phase"], nxt.get("kind"))
            copy_pack = build_moon_copy_from_rules(rules, echoes, phase_for_rules, ev_sign, nxt["date"], label)
            when_label = "Today" if days_out == 0 else f"in {days_out} days"
            sign_label = f"{ev_sign} " if ev_sign else ""
            return {
                "state": "countdown",
                "rule_id": copy_pack["rule_id"] or f"meta.countdown.{phase_for_rules}",
                "title": f"Next {label} {when_label} — {sign_label}{label}",
                "subtitle": f"Exact on {pretty_date_str(nxt['date'])}" + (" • estimated" if nxt.get("estimated") else ""),
                "future_theme": copy_pack["future_theme"],
                "echoes": copy_pack["echoes"],
                "estimated": bool(nxt.get("estimated", False))
            }
        cd_new  = _countdown(d, pair_day["next_new"])
        cd_full = _countdown(d, pair_day["next_full"])

        d0 = datetime.strptime(d, "%Y-%m-%d").date()
        d_new  = datetime.strptime(pair_day["next_new"]["date"],  "%Y-%m-%d").date()
        d_full = datetime.strptime(pair_day["next_full"]["date"], "%Y-%m-%d").date()
        earlier_cd = cd_new if (d_new - d0).days <= (d_full - d0).days else cd_full

        result["weekly_aspects"].append({
            "date": d,
            "moon": moon_blob,
            "aspects": aspects_with_cards,
            "moon_anchor_card": moon_anchor_card,
            "countdown_new_card": cd_new,
            "countdown_full_card": cd_full,
            "countdown_card": earlier_cd
        })

    # Add a complete lunation/eclipses list for this window (for a dedicated JSON)
    all_events = list_lunations_for_window(
        eph_by_day,
        window[0],
        window[-1]
    )
    # decorate with sign + rule copy
    decorated = []
    for ev in all_events:
        label = phase_nice_label(ev.get("phase",""), ev.get("kind"))
        phase_for_rules = "new" if (ev.get("phase")=="new" or ev.get("kind")=="solar_eclipse") else "full"
        ev_sign = event_sign(eph_by_day, ev["date"], ev["phase"], ev.get("kind"))
        copy_pack = build_moon_copy_from_rules(rules, echoes, phase_for_rules, ev_sign, ev["date"], label)
        decorated.append({
            "date": ev["date"],
            "phase": ev["phase"],
            "kind": ev.get("kind", ev["phase"]),
            "sign": ev_sign,
            "title": copy_pack["title"],
            "future_theme": copy_pack["future_theme"],
            "echoes": copy_pack["echoes"],
            "rule_id": copy_pack["rule_id"],
            "estimated": bool(ev.get("estimated", False))
        })
    result["lunation_events"] = decorated
    return result

# ----------------
# Exports (write into a folder)
# ----------------
def ensure_dir(p: str):
    os.makedirs(p, exist_ok=True)

def write_main(result: Dict[str,Any], base_path: str) -> str:
    ensure_dir(base_path)
    p = f"{base_path}/forecast_mundaneevents.json"
    with open(p, "w", encoding="utf-8") as f:
        json.dump(result, f, ensure_ascii=False, indent=2)
    print("✅ wrote", p)
    return p

def export_jsons(result: Dict[str,Any], base_path: str="/content") -> Dict[str,str]:
    ensure_dir(base_path)
    paths = {}

    # 1) All aspects
    all_payload = {
        "generated_utc": result["generated_utc"],
        "window": result["window"],
        "days": [{"date": d["date"], "aspects": d["aspects"]} for d in result["weekly_aspects"]]
    }
    p_all = f"{base_path}/forecast_aspects_all.json"
    with open(p_all, "w", encoding="utf-8") as f:
        json.dump(all_payload, f, ensure_ascii=False, indent=2)
    paths["all_aspects"] = p_all

    # 2) Matched
    matched_days = []
    for d in result["weekly_aspects"]:
        ev = [a for a in d["aspects"] if (a.get("card",{}).get("state")=="matched")]
        matched_days.append({"date": d["date"], "aspects": ev})
    matched_payload = {"generated_utc": result["generated_utc"], "window": result["window"], "days": matched_days}
    p_matched = f"{base_path}/forecast_aspects_matched.json"
    with open(p_matched, "w", encoding="utf-8") as f:
        json.dump(matched_payload, f, ensure_ascii=False, indent=2)
    paths["matched_aspects"] = p_matched

    # 3) Unmatched
    unmatched_days = []
    for d in result["weekly_aspects"]:
        ev = [a for a in d["aspects"] if (a.get("card",{}).get("state")=="unmatched")]
        unmatched_days.append({"date": d["date"], "aspects": ev})
    unmatched_payload = {"generated_utc": result["generated_utc"], "window": result["window"], "days": unmatched_days}
    p_unmatched = f"{base_path}/forecast_aspects_unmatched.json"
    with open(p_unmatched, "w", encoding="utf-8") as f:
        json.dump(unmatched_payload, f, ensure_ascii=False, indent=2)
    paths["unmatched_aspects"] = p_unmatched

    # 4) Moon events (meta + per-day anchor & countdowns)
    moon_days = []
    for d in result["weekly_aspects"]:
        moon_days.append({
            "date": d["date"],
            "moon": d["moon"],
            "moon_anchor_card": d.get("moon_anchor_card"),
            "countdown_new_card": d.get("countdown_new_card"),
            "countdown_full_card": d.get("countdown_full_card"),
            "countdown_card": d.get("countdown_card")
        })
    moon_payload = {"generated_utc": result["generated_utc"], "window": result["window"], "meta": result.get("meta", {}), "days": moon_days}
    p_moon = f"{base_path}/forecast_moon_events.json"
    with open(p_moon, "w", encoding="utf-8") as f:
        json.dump(moon_payload, f, ensure_ascii=False, indent=2)
    paths["moon_events"] = p_moon

    # 5) Eclipses-only list (subset of lunation_events)
    eclipses = [e for e in (result.get("lunation_events") or []) if e.get("kind") in {"solar_eclipse","lunar_eclipse"}]
    eclipse_payload = {"generated_utc": result["generated_utc"], "window": result["window"], "eclipses": eclipses}
    p_eclipses = f"{base_path}/forecast_eclipses.json"
    with open(p_eclipses, "w", encoding="utf-8") as f:
        json.dump(eclipse_payload, f, ensure_ascii=False, indent=2)
    paths["eclipses"] = p_eclipses

    # Console summary
    total_all = sum(len(d["aspects"]) for d in all_payload["days"])
    total_matched = sum(len(d["aspects"]) for d in matched_payload["days"])
    total_unmatched = sum(len(d["aspects"]) for d in unmatched_payload["days"])
    print(f"🗂 wrote {p_all}      • events={total_all}")
    print(f"🗂 wrote {p_matched}  • matched={total_matched}")
    print(f"🗂 wrote {p_unmatched}• unmatched={total_unmatched}")
    print(f"🗂 wrote {p_moon}     • days={len(moon_payload['days'])}  (meta keys={list(moon_payload.get('meta',{}).keys())})")
    print(f"🗂 wrote {p_eclipses} • eclipses={len(eclipses)}")
    return paths

# ----------------
# Run BOTH windows (7d + Annual) and export into two folders
# ----------------
ensure_dir(DIR_7D)
ensure_dir(DIR_ANNUAL)
ensure_dir(DIR_SAMPLE)  # harmless if not used

print("TE ▶︎ building 7-day window…")
result_7d = build_window(None, 7)
write_main(result_7d, str(DIR_7D))
export_jsons(result_7d, str(DIR_7D))

print("TE ▶︎ building annual window (366d)…")
result_annual = build_window(None, 366)
write_main(result_annual, str(DIR_ANNUAL))
export_jsons(result_annual, str(DIR_ANNUAL))

# small peek
def peek(result, label):
    print(f"\n— Preview ({label}) —")
    print("window:", result["window"])
    print("meta.next_new_moon:", result["meta"].get("next_new_moon"))
    print("meta.next_full_moon:", result["meta"].get("next_full_moon"))
    if result.get("lunation_events"):
        first_ev = result["lunation_events"][0]
        print("first lunation event:", {k:first_ev[k] for k in ["date","phase","kind","sign","title"]})

peek(result_7d, "7d")
peek(result_annual, "annual")

"""# remove directory

"""

# !rm -rf /content/forecast_annual
# !rm -rf /content/forecast_7d

"""# SECOND BLOCK


# ** eclipse detector **
"""

# Colab Cell — Isolated Syzygy & Eclipse Detector (ephemeris-only; current+next year)
# - Loads your ephemeris for this year + next year (avoids 404 on further years)
# - Normalizes keys (YYYY-MM-DD) and body names (lowercase)
# - Computes mean lunar node if Node is absent (Meeus)
# - Finds all New/Full inside a test window and tags Solar/Lunar eclipses
# - Writes Mac/GitHub-safe debug files under BASE_DIR/eclipse_debug
# - Prints a compact console report

# NOTE: do NOT add another `from __future__ import annotations` here.

import json, re, requests, math, os
from datetime import datetime, timedelta, timezone, date
from typing import Dict, Any, Optional, List, Tuple

EPHEMERIS_URL_TMPL = "https://raw.githubusercontent.com/Stp155906/ephemeris/refs/heads/main/{year}_ephemeris_with_signs.json"

# Eclipse windows (node-separation heuristic, degrees)
ECLIPSE_NODE_THRESHOLD_NEW_DEG  = 17.0  # solar
ECLIPSE_NODE_THRESHOLD_FULL_DEG = 11.0  # lunar

NODE_KEYS = ["true node", "mean node", "north node", "node", "lunar node", "rahu"]
SIGNS = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"]
SIGN_TO_INDEX = {s:i for i,s in enumerate(SIGNS)}

# ---------- Helpers: JSON5-ish loader ----------
def _strip_json_comments(s: str) -> str:
    s = re.sub(r'(?m)^[ \t]*//.*$', '', s)
    s = re.sub(r'/\*[\s\S]*?\*/', '', s)
    s = re.sub(r',\s*([}\]])', r'\1', s)
    return s

def load_json5(url: str) -> Any:
    r = requests.get(url, timeout=30)
    if r.status_code == 404:
        raise requests.HTTPError("404", response=r)
    r.raise_for_status()
    t = r.text
    try:
        return json.loads(t)
    except json.JSONDecodeError:
        return json.loads(_strip_json_comments(t))

_DATE_RE  = re.compile(r"^\d{4}-\d{2}-\d{2}$")
_MONTH_RE = re.compile(r"^\d{4}-\d{2}$")

def _month_name_to_num(mname: str) -> Optional[int]:
    try:
        return datetime.strptime(mname.strip(), "%B").month
    except:
        return None

# ---------- Ephemeris loader (year → month → day → bodies) ----------
def fetch_ephemeris_for_year(year: int) -> Dict[str, Dict[str,str]]:
    url = EPHEMERIS_URL_TMPL.format(year=year)
    norm: Dict[str, Dict[str,str]] = {}
    try:
        data = load_json5(url) or {}
    except requests.HTTPError as he:
        code = getattr(he.response, "status_code", None)
        print(f"⚠️ {year}: HTTP {code} — skipping")
        return {}
    except Exception as e:
        print(f"⚠️ {year}: fetch/parse failed — {e}")
        return {}

    if not isinstance(data, dict):
        print(f"⚠️ {year}: unexpected root {type(data)}")
        return {}

    for key, val in data.items():
        # A) Day keys (YYYY-MM-DD)
        if isinstance(val, dict) and _DATE_RE.match(key):
            norm[key] = {k.lower(): v for k, v in val.items()}
            continue
        # B) Month buckets (YYYY-MM → days)
        if isinstance(val, dict) and _MONTH_RE.match(key):
            month_prefix = key
            for dkey, bodies in val.items():
                if not isinstance(bodies, dict): continue
                try:
                    dd = int(str(dkey).strip())
                    iso = f"{month_prefix}-{dd:02d}"
                    norm[iso] = {k.lower(): v for k, v in bodies.items()}
                except:
                    pass
            continue
        # C) Month-name buckets ("January" → days)
        mnum = _month_name_to_num(key)
        if isinstance(val, dict) and mnum is not None:
            for dkey, bodies in val.items():
                if not isinstance(bodies, dict): continue
                try:
                    dd = int(str(dkey).strip())
                    iso = f"{year}-{mnum:02d}-{dd:02d}"
                    norm[iso] = {k.lower(): v for k, v in bodies.items()}
                except:
                    pass

    print(f"✅ {year}: normalized days={len(norm)}")
    return norm

def load_ephemeris_current_plus_next(start_date: date) -> Dict[str, Dict[str,str]]:
    years = [start_date.year, start_date.year + 1]
    out: Dict[str, Dict[str,str]] = {}
    for y in years:
        out.update(fetch_ephemeris_for_year(y))
    return dict(sorted(out.items(), key=lambda kv: kv[0]))

# ---------- Parsing positions like "Leo 12 34" / "Leo 12°34'" ----------
def parse_lon_deg(pos: str) -> Optional[float]:
    if not pos: return None
    s = pos.strip().replace("’"," ").replace("′"," ").replace("'", " ").replace("°"," ")
    m = re.search(r"([A-Za-z]+)\s+(\d+)(?:\s+(\d+))?", s)
    if not m:
        return None
    sign = m.group(1).title()
    deg  = int(m.group(2))
    minute = int(m.group(3)) if m.group(3) else 0
    idx = SIGN_TO_INDEX.get(sign)
    if idx is None:
        return None
    return idx*30 + deg + minute/60.0

def body_lon(eph_by_day: Dict[str,Dict[str,str]], day_iso: str, body: str) -> Optional[float]:
    row = eph_by_day.get(day_iso) or {}
    return parse_lon_deg(row.get(body))

def angle_diff(a: float, b: float) -> float:
    """Signed shortest difference b - a in (-180, +180]."""
    d = (b - a) % 360.0
    if d > 180.0: d -= 360.0
    return d

# ---------- Mean lunar node (Meeus) if node not in ephemeris ----------
def mean_node_longitude_deg(d: date) -> float:
    """
    Mean longitude of the Moon's ascending node (degrees), rough Meeus form.
    T = centuries since J2000 (TT ~ UTC good enough for our day-level use).
    λΩ = 125.04452° - 1934.136261°*T + 0.0020708°*T² + T³/450000
    Return normalized [0,360).
    """
    # Convert date to Julian centuries since J2000.0 (UTC approximation)
    # JDN at 2000-01-01 12:00 UT is 2451545.0
    y, m, day = d.year, d.month, d.day
    if m <= 2:
        y -= 1; m += 12
    A = y // 100
    B = 2 - A + A // 5
    jd = int(365.25*(y+4716)) + int(30.6001*(m+1)) + day + B - 1524.5
    T = (jd - 2451545.0) / 36525.0

    lam = 125.04452 - 1934.136261*T + 0.0020708*(T*T) + (T*T*T)/450000.0
    lam = lam % 360.0
    return lam

def node_lon_for_date(eph_by_day: Dict[str,Dict[str,str]], day_iso: str) -> Optional[float]:
    # Prefer node from ephemeris if present
    row = eph_by_day.get(day_iso) or {}
    for k in NODE_KEYS:
        if k in row:
            val = parse_lon_deg(row[k])
            if val is not None:
                return val
    # Else compute mean node
    d = datetime.strptime(day_iso, "%Y-%m-%d").date()
    return mean_node_longitude_deg(d)

# ---------- Phase helpers ----------
def closest_phase_on_or_after(start_iso: str, eph_by_day: Dict[str,Dict[str,str]], target: str, horizon: int = 45) -> Optional[Dict[str,Any]]:
    """Choose the date in [start, start+horizon] whose Moon-Sun angle is closest to 0° (new) or 180° (full)."""
    want = 0.0 if target == "new" else 180.0
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    best: Optional[Tuple[float,int,str]] = None
    for i in range(0, horizon+1):
        d = (start + timedelta(days=i)).isoformat()
        sun  = body_lon(eph_by_day, d, "sun")
        moon = body_lon(eph_by_day, d, "moon")
        if sun is None or moon is None:
            continue
        delta = (moon - sun) % 360.0
        dist  = abs(((delta - want + 180.0) % 360.0) - 180.0)
        if (best is None) or (dist < best[0]) or (dist == best[0] and i < best[1]):
            best = (dist, i, d)
    if not best:
        return None
    return {"date": best[2], "phase": target, "kind": target, "estimated": True}

def tag_eclipse(eph_by_day: Dict[str,Dict[str,str]], ev: Dict[str,Any]) -> Dict[str,Any]:
    """If |λ☉ - Ω| within window on that date, mark as solar/lunar eclipse."""
    out = dict(ev)
    sun = body_lon(eph_by_day, ev["date"], "sun")
    node = node_lon_for_date(eph_by_day, ev["date"])
    if sun is None or node is None:
        return out
    sep = abs(angle_diff(node, sun))  # node vs sun
    if ev["phase"] == "new"  and sep <= ECLIPSE_NODE_THRESHOLD_NEW_DEG:
        out["kind"] = "solar_eclipse"
    if ev["phase"] == "full" and sep <= ECLIPSE_NODE_THRESHOLD_FULL_DEG:
        out["kind"] = "lunar_eclipse"
    return out

def list_syzygies_with_eclipses(eph_by_day: Dict[str,Dict[str,str]], start_iso: str, end_iso: str) -> List[Dict[str,Any]]:
    """Return all New/Full within [start, end], tagged if eclipse per node proximity."""
    events: List[Dict[str,Any]] = []
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    end   = datetime.strptime(end_iso,   "%Y-%m-%d").date()

    def collect(which: str):
        cur = start
        while cur <= end + timedelta(days=1):
            nxt = closest_phase_on_or_after(cur.isoformat(), eph_by_day, which, horizon=45)
            if not nxt: break
            d = datetime.strptime(nxt["date"], "%Y-%m-%d").date()
            if d > end: break
            events.append(tag_eclipse(eph_by_day, nxt))
            # hop to next cycle (29.5-ish). Starting 2 days after avoids re-picking the same day.
            cur = d + timedelta(days=2)

    collect("new")
    collect("full")

    # sort and de-dup
    events.sort(key=lambda e: (e["date"], 0 if e["phase"]=="new" else 1))
    uniq, seen = [], set()
    for ev in events:
        k = (ev["date"], ev["phase"])
        if k not in seen:
            seen.add(k); uniq.append(ev)
    return uniq

# ---------- Run: load ephemeris + detect ----------
today = datetime.now(timezone.utc).date()
eph = load_ephemeris_current_plus_next(today)

# quick sanity print
keys_sorted = sorted(eph.keys())
if not keys_sorted:
    raise RuntimeError("No ephemeris loaded. Ensure  {this_year}_ephemeris_with_signs.json  and  {next_year}_ephemeris_with_signs.json  exist in your repo.")

dmin, dmax = keys_sorted[0], keys_sorted[-1]
print("\n—— EPHEMERIS LOADED ——")
print(f"Days: {len(keys_sorted)}")
print(f"Range: {dmin} → {dmax}")
print(f"Sample first day: {dmin}  ::  { {k:v for k,v in eph[dmin].items() if k in ['sun','moon'] or k in NODE_KEYS} }")

# choose a test window: from today through +370 days (bounded by what's available)
window_start = max(today.isoformat(), dmin)
window_end   = min((today + timedelta(days=370)).isoformat(), dmax)

events = list_syzygies_with_eclipses(eph, window_start, window_end)

# enrich with sign/labels for preview
def _extract_sign(pos: str) -> str:
    return (pos or "").split(" ")[0].title()

decor = []
for ev in events:
    if ev["phase"] == "new" or ev.get("kind")=="solar_eclipse":
        pos = (eph.get(ev["date"], {}) or {}).get("sun","")
    else:
        pos = (eph.get(ev["date"], {}) or {}).get("moon","")
    sign = _extract_sign(pos)
    label = "Solar Eclipse" if ev.get("kind")=="solar_eclipse" else ("Lunar Eclipse" if ev.get("kind")=="lunar_eclipse" else ("New Moon" if ev["phase"]=="new" else "Full Moon"))
    decor.append({**ev, "sign": sign, "label": label})

# --- Write debug files (Mac-safe, also fine on GitHub) ---
OUT_DIR = str(BASE_DIR / "eclipse_debug")
os.makedirs(OUT_DIR, exist_ok=True)

ephemeris_path = os.path.join(OUT_DIR, "_ephemeris_merged.json")
events_path    = os.path.join(OUT_DIR, "_eclipse_test_events.json")

with open(ephemeris_path, "w", encoding="utf-8") as f:
    json.dump(eph, f, ensure_ascii=False, indent=2)

with open(events_path, "w", encoding="utf-8") as f:
    json.dump({"start": window_start, "end": window_end, "events": decor}, f, ensure_ascii=False, indent=2)

print("\n—— SYZYGY / ECLIPSE TEST ——")
print(f"Window: {window_start} → {window_end}")
print(f"Total events: {len(decor)} (new/full + any eclipses tagged)")
for ev in decor[:6]:
    print(f"  {ev['date']}: {ev['label']} — sign={ev['sign']}  (phase={ev['phase']}, kind={ev.get('kind')})")

print(f"\n📦 Wrote {ephemeris_path} and {events_path}")

"""# THIRD BLOCK

## Generate eclipse matches
"""

# Colab Cell 3 — Write eclipse lists into the main folders (7d + annual)
# Inputs:
#   BASE_DIR/eclipse_debug/_ephemeris_merged.json  (from your ephemeris self-test cell)
#   rules.json / echo_catalog.json   (GitHub)
# Outputs:
#   forecast_7d/forecast_eclipses.json
#   forecast_annual/forecast_eclipses.json

import json, re, os
from datetime import datetime, timedelta, timezone, date
from typing import Dict, Any, List, Optional
import requests

# ---------------------------
# Paths / config (Mac/GitHub-safe)
# ---------------------------
EPH_TRY = [str(BASE_DIR / "eclipse_debug" / "_ephemeris_merged.json")]
OUT_7D      = str(DIR_7D)
OUT_ANNUAL  = str(DIR_ANNUAL)
for p in (OUT_7D, OUT_ANNUAL):
    os.makedirs(p, exist_ok=True)

RULES_URL   = "https://raw.githubusercontent.com/Stp155906/mundane-cycles/refs/heads/main/rules.json"
ECHOES_URL  = "https://raw.githubusercontent.com/Stp155906/mundane-cycles/refs/heads/main/echo_catalog.json"

LOOKAHEAD = 60
ECLIPSE_NODE_THRESHOLD_NEW_DEG  = 17.0
ECLIPSE_NODE_THRESHOLD_FULL_DEG = 11.0
NODE_KEYS = ["true node", "mean node", "north node", "node", "lunar node", "rahu"]

SIGNS = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"]
SIGN_TO_INDEX = {s:i for i,s in enumerate(SIGNS)}

# ---------------------------
# Utilities
# ---------------------------
def _strip_json_comments(s: str) -> str:
    s = re.sub(r'(?m)^[ \t]*//.*$', '', s)
    s = re.sub(r'/\*[\s\S]*?\*/', '', s)
    s = re.sub(r',\s*([}\]])', r'\1', s)
    return s

def load_json5_url(url: str) -> Any:
    r = requests.get(url, timeout=30); r.raise_for_status()
    t = r.text
    try: return json.loads(t)
    except json.JSONDecodeError: return json.loads(_strip_json_comments(t))

def tcase(x: str) -> str: return (x or "").strip().title()

def pretty_date_str(yyyy_mm_dd: str) -> str:
    try:
        dt = datetime.strptime(yyyy_mm_dd, "%Y-%m-%d").date()
        try:    return dt.strftime("%b %-d, %Y")
        except: return dt.strftime("%b %#d, %Y")
    except: return yyyy_mm_dd

def render_template(s: str, d: str) -> str:
    dl = pretty_date_str(d)
    return (s or "").replace("{{date_local}}", dl).replace("{date_local}", dl)

def phase_nice_label(phase: str, kind: Optional[str]) -> str:
    k = (kind or phase or "").lower()
    if k == "solar_eclipse": return "Solar Eclipse"
    if k == "lunar_eclipse": return "Lunar Eclipse"
    return "New Moon" if (phase or "").lower()=="new" else "Full Moon"

# ---------------------------
# Ephemeris helpers (from TEST file)
# ---------------------------
def _parse_lon_deg(pos: str) -> Optional[float]:
    if not pos: return None
    clean = pos.replace("’"," ").replace("'", " ")
    m = re.search(r"([A-Za-z]+)\s+(\d+)\s+(\d+)", clean)
    if not m: return None
    sign, deg, minute = m.group(1).title(), int(m.group(2)), int(m.group(3))
    idx = SIGN_TO_INDEX.get(sign)
    if idx is None: return None
    return idx*30 + deg + minute/60.0

def _body_lon(eph: Dict[str,Dict[str,str]], day: str, body: str) -> Optional[float]:
    row = eph.get(day) or {}
    pos = row.get(body.lower())
    return _parse_lon_deg(pos)

def _angle_diff(a: float, b: float) -> float:
    d = (b - a) % 360.0
    if d >= 180.0: d -= 360.0
    return d

def _phase_name_from_angle(delta_deg: float) -> str:
    a = delta_deg % 360.0
    if   a < 22.5 or a >= 337.5: return "new"
    elif a < 67.5:  return "waxing crescent"
    elif a < 112.5: return "first quarter"
    elif a < 157.5: return "waxing gibbous"
    elif a < 202.5: return "full"
    elif a < 247.5: return "waning gibbous"
    elif a < 292.5: return "last quarter"
    else:           return "waning crescent"

def _node_lon_from_ephemeris(eph: Dict[str,Dict[str,str]], day: str) -> Optional[float]:
    row = eph.get(day) or {}
    for k in NODE_KEYS:
        if k in row:
            return _parse_lon_deg(row[k])
    return None

# Fallback mean node (Meeus)
def _julian_day(dt: date) -> float:
    a = (14 - dt.month)//2
    y = dt.year + 4800 - a
    m = dt.month + 12*a - 3
    jd = dt.day + ((153*m + 2)//5) + 365*y + y//4 - y//100 + y//400 - 32045
    return float(jd)

def _mean_node_lon_meeus(dt: date) -> float:
    JD = _julian_day(dt)
    T = (JD - 2451545.0)/36525.0
    omega = 125.04452 - 1934.136261*T + 0.0020708*(T**2) + (T**3)/450000.0
    return omega % 360.0

def _node_lon(eph: Dict[str,Dict[str,str]], day_iso: str) -> float:
    node = _node_lon_from_ephemeris(eph, day_iso)
    if node is not None: return node
    dt = datetime.strptime(day_iso, "%Y-%m-%d").date()
    return _mean_node_lon_meeus(dt)

# ---------------------------
# Rules / echoes
# ---------------------------
def fetch_rules_and_echoes():
    rules_doc = load_json5_url(RULES_URL) or {}
    echoes_doc = load_json5_url(ECHOES_URL) or {}
    rules  = rules_doc.get("rules", []) if isinstance(rules_doc, dict) else []
    echoes = echoes_doc.get("echoes", []) if isinstance(echoes_doc, dict) else []
    print(f"TE ▶︎ rules={len(rules)} echoes={len(echoes)}")
    return rules, echoes

def find_moon_rule(rules: List[Dict[str,Any]], phase_for_rules: str, sign: str) -> Optional[Dict[str,Any]]:
    phase_for_rules = (phase_for_rules or "").lower()
    sign = tcase(sign)
    best = None
    for r in rules:
        if r.get("type") != "moon_phase": continue
        m = r.get("match", {})
        if (m.get("phase","").lower() != phase_for_rules): continue
        need_sign = tcase(m.get("sign",""))
        if need_sign and sign == need_sign:
            if (best is None) or (float(r.get("priority",0)) > float(best.get("priority",0))):
                best = r
    if best: return best
    for r in sorted([x for x in rules if x.get("type")=="moon_phase"], key=lambda z: float(z.get("priority",0)), reverse=True):
        m = r.get("match", {})
        if (m.get("phase","").lower() == phase_for_rules) and not m.get("sign"):
            return r
    return None

def build_moon_copy_from_rules(rules, echoes, phase_for_rules, sign, date_iso, default_label) -> Dict[str,Any]:
    r = find_moon_rule(rules, phase_for_rules, sign)
    if r:
        title_tmpl = (r.get("copy", {}) or {}).get("title_template") or (
            f"{tcase(sign)} {default_label} → {{date_local}}" if sign else f"{default_label} → {{date_local}}"
        )
        title = render_template(title_tmpl, date_iso)
        future_theme = (r.get("copy", {}) or {}).get("future_theme", "")
        echo_ids = r.get("echo_ids") or []
        echo_map = {e.get("id"): e for e in echoes}
        echo_objs = [echo_map[eid] for eid in echo_ids if eid in echo_map]
        return {"title": title, "future_theme": future_theme or "Major tide change. Honor the phase’s tone.", "echoes": echo_objs, "rule_id": r.get("id","")}
    base = f"{tcase(sign)} {default_label}" if sign else default_label
    return {"title": f"{base} → {pretty_date_str(date_iso)}", "future_theme": "This upcoming lunation is a reset/culmination point. Notice what’s ending and what wants to begin.", "echoes": [], "rule_id": f"meta.{phase_for_rules}.default"}

# ---------------------------
# Lunations + eclipse tagging on TEST ephemeris
# ---------------------------
def _closest_phase_on_or_after(eph: Dict[str,Dict[str,str]], start_iso: str, target: str, horizon: int=LOOKAHEAD) -> Optional[Dict[str,Any]]:
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    want = 0.0 if target == "new" else 180.0
    best = None
    for i in range(0, horizon+1):
        d = (start + timedelta(days=i)).isoformat()
        sun = _body_lon(eph, d, "sun")
        moon = _body_lon(eph, d, "moon")
        if sun is None or moon is None: continue
        delta = ((moon - sun) % 360.0)
        dist = abs(((delta - want + 180.0) % 360.0) - 180.0)
        if (best is None) or (dist < best[0]) or (dist == best[0] and i < best[1]):
            best = (dist, i, d)
    if not best: return None
    return {"date": best[2], "phase": target, "kind": target, "estimated": True}

def list_lunations_for_window(eph: Dict[str,Dict[str,str]], start_iso: str, end_iso: str) -> List[Dict[str,Any]]:
    events: List[Dict[str,Any]] = []
    start = datetime.strptime(start_iso, "%Y-%m-%d").date()
    end   = datetime.strptime(end_iso,   "%Y-%m-%d").date()

    def collect_sequence(which: str):
        cur = start
        while cur <= end + timedelta(days=1):
            nxt = _closest_phase_on_or_after(eph, cur.isoformat(), which, horizon=40)
            if not nxt: break
            d = datetime.strptime(nxt["date"], "%Y-%m-%d").date()
            if d > end: break
            # eclipse tagging (ephemeris node if present; else mean node)
            sun = _body_lon(eph, nxt["date"], "sun")
            node = _node_lon(eph, nxt["date"])
            if (sun is not None) and (node is not None):
                sep = abs(_angle_diff(sun, node))
                if nxt["phase"]=="new"  and sep <= ECLIPSE_NODE_THRESHOLD_NEW_DEG:  nxt["kind"] = "solar_eclipse"
                if nxt["phase"]=="full" and sep <= ECLIPSE_NODE_THRESHOLD_FULL_DEG: nxt["kind"] = "lunar_eclipse"
            events.append(nxt)
            cur = d + timedelta(days=2)

    collect_sequence("new")
    collect_sequence("full")
    events.sort(key=lambda e: (e["date"], 0 if e["phase"]=="new" else 1))
    uniq, seen = [], set()
    for e in events:
        k = (e["date"], e["phase"])
        if k not in seen:
            seen.add(k); uniq.append(e)
    return uniq

def event_sign(eph: Dict[str,Dict[str,str]], date_iso: str, phase: str, kind: Optional[str]) -> str:
    use_sun = (phase=="new") or (kind=="solar_eclipse")
    row = eph.get(date_iso, {}) or {}
    pos = row.get("sun" if use_sun else "moon", "")
    return (pos or "").split(" ")[0].title().strip() if pos else ""

def decorate_events(eph: Dict[str,Dict[str,str]], rules, echoes, evs: List[Dict[str,Any]]) -> List[Dict[str,Any]]:
    out = []
    for ev in evs:
        label = phase_nice_label(ev.get("phase",""), ev.get("kind"))
        phase_for_rules = "new" if (ev.get("phase")=="new" or ev.get("kind")=="solar_eclipse") else "full"
        sign = event_sign(eph, ev["date"], ev["phase"], ev.get("kind"))
        pack = build_moon_copy_from_rules(rules, echoes, phase_for_rules, sign, ev["date"], label)
        out.append({
            "date": ev["date"],
            "phase": ev["phase"],
            "kind": ev.get("kind", ev["phase"]),
            "sign": sign,
            "title": pack["title"],
            "future_theme": pack["future_theme"],
            "echoes": pack["echoes"],
            "rule_id": pack["rule_id"],
            "estimated": bool(ev.get("estimated", False))
        })
    return out

# ---------------------------
# Load TEST ephemeris
# ---------------------------
eph = {}
for p in EPH_TRY:
    if os.path.exists(p):
        with open(p, "r", encoding="utf-8") as f:
            eph = json.load(f)
        print(f"📦 Loaded ephemeris test data: {p} (days={len(eph)})")
        break
if not eph:
    raise FileNotFoundError("Run your ephemeris self-test cell first to write _ephemeris_merged.json.")

# Determine windows inside available range
all_days = sorted(eph.keys())
avail_start = datetime.strptime(all_days[0], "%Y-%m-%d").date()
avail_end   = datetime.strptime(all_days[-1], "%Y-%m-%d").date()
today = datetime.now(timezone.utc).date()
start = max(today, avail_start)

win_7d_start = start
win_7d_end   = min(avail_end, start + timedelta(days=6))     # 7 days inclusive
win_yr_start = start
win_yr_end   = min(avail_end, start + timedelta(days=365))   # 366-day span inclusive

print(f"Range available: {avail_start} → {avail_end}")
print(f"Windows: 7d={win_7d_start}..{win_7d_end}  • annual={win_yr_start}..{win_yr_end}")

# ---------------------------
# Build + write into your main folders
# ---------------------------
rules, echoes = fetch_rules_and_echoes()

def write_eclipses(eph, start_d: date, end_d: date, out_folder: str):
    evs = list_lunations_for_window(eph, start_d.isoformat(), end_d.isoformat())
    deco = decorate_events(eph, rules, echoes, evs)
    eclipses = [e for e in deco if e["kind"] in {"solar_eclipse","lunar_eclipse"}]
    payload = {
        "generated_utc": datetime.now(timezone.utc).isoformat(timespec="seconds").replace("+00:00","Z"),
        "window": {"start": start_d.isoformat(), "end": end_d.isoformat()},
        "eclipses": eclipses
    }
    p = os.path.join(out_folder, "forecast_eclipses.json")
    with open(p, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    print(f"✅ wrote {p} • eclipses={len(eclipses)}")
    if eclipses:
        print("first eclipse:", {k:eclipses[0][k] for k in ["date","kind","sign","title"]})

# Write to the SAME folders your main exporter uses
write_eclipses(eph, win_7d_start, win_7d_end, OUT_7D)
write_eclipses(eph, win_yr_start, win_yr_end, OUT_ANNUAL)
